//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3);
bool function_401000(int32_t a1);
void function_401084(int32_t a1);
int32_t function_401097(int32_t a1);

// --------------------- Global Variables ---------------------

bool g1 = false; // eaf
int32_t g2 = 0; // eax
int32_t g3 = 0; // ebp
int32_t g4 = 0; // ebx
int32_t g5 = 0; // ecx
bool g6 = false; // edf
int32_t g7 = 0; // esp

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401083
bool function_401000(int32_t a1) {
    int32_t * hFile2 = GetStdHandle(-10); // 0x40100c
    int32_t hFile = (int32_t)GetStdHandle(-11); // 0x401030
    char * lpNumberOfBytesWritten;
    WriteFile(hFile, "You crushed that last one! Let's up the game.
Enter the password>", 67, (int32_t *)&lpNumberOfBytesWritten, NULL);
    ReadFile(hFile2, "", 50, (int32_t *)&lpNumberOfBytesWritten, NULL);
    int32_t * v1;
    function_401084((int32_t)v1);
    char * v2 = (int32_t)&lpNumberOfBytesWritten == 0 ? "You are failure
" : "You are success
";
    g7 = (int32_t)&v2;
    bool result = WriteFile(hFile, "You are failure
", 17, (int32_t *)&lpNumberOfBytesWritten, NULL); // 0x40107a
    g3 = (int32_t)(int32_t *)g3;
    return result;
}

// Address range: 0x401084 - 0x401095
void function_401084(int32_t a1) {
    // 0x401084
    g4 = 0;
    g5 = 37;
}

// Address range: 0x401097 - 0x4010de
int32_t function_401097(int32_t a1) {
    // 0x401097
    int32_t v1; // 0x401097
    if (g1 || (g2 & 14) > 9) {
        // if_401097_0_true
        // branch -> after_if_401097_0
    } else {
        // if_401097_0_false
        v1 = g2 & -241;
        // branch -> after_if_401097_0
    }
    int32_t v2 = *(int32_t *)(g3 + 12); // esi
    int32_t v3 = *(int32_t *)(g3 + 8) - 1 + g5; // edi
    bool v4 = false; // 0x4010b0
    bool v5 = false; // 0x4010b0
    bool v6 = false; // 0x4010b0
    bool v7 = false; // 0x4010b0
    bool v8 = false; // 0x4010b0
    bool v9 = g6; // 0x4010b0
    int32_t v10 = g4; // 0x4010a2
    // branch -> 0x4010a2
    int32_t result; // 0x4010cd
    while (true) {
        int32_t v11 = v1 & -0x10000 | 455; // 0x4010a9
        int32_t v12 = g7 - 4; // 0x4010ad
        int32_t * v13 = (int32_t *)v12; // 0x4010ad_0
        *v13 = v11;
        int32_t v14 = v2; // 0x4010af
        v2 = v14 + (v9 ? -1 : 1);
        uint32_t v15 = v11 / 256; // 0x4010ae
        int32_t v16 = v8 ? 256 : 0; // 0x4010b0
        int32_t v17 = v7 ? 512 : 0; // 0x4010b0
        int32_t v18 = v6 ? 0x4000 : 0; // 0x4010b0
        int32_t v19 = v5 ? 0x40000 : 0; // 0x4010b0
        int32_t v20 = v4 ? 0x200000 : 0; // 0x4010b0
        int32_t v21 = v9 ? 1026 : 2; // 0x4010b0
        int32_t * v22 = (int32_t *)(g7 - 8); // 0x4010b0_0
        *v22 = v21 | v15 & 4 | (v11 & 0x1000) / 256 | v15 & 64 | v15 & 128 | (int32_t)((v11 & 256) != 0) | v16 | v17 | v18 | v19 | v20;
        uint32_t v23 = (int32_t)*(char *)v14 | v11 & -256; // 0x4010b1
        int32_t v24 = (int32_t)*(char *)v12 ^ v23; // 0x4010b1
        int32_t v25 = g5; // 0x4010b5
        uint32_t v26 = v23 / 256 & 255; // 0x4010b7
        uint32_t v27 = v10 & 3 & 7; // 0x4010b7
        int32_t v28 = v24; // 0x4010ba
        if (v27 != 0) {
            int32_t v29 = 256 * (v26 >> 8 - v27 | v26 << v27) & 0xff00 | v24 & -0xff01; // 0x4010b7
            v28 = v29;
            // branch -> after_if_4010b7_0
        }
        int32_t v30 = *v22; // 0x4010b9
        uint32_t v31 = v30 & 1024; // 0x4010b9
        int32_t v32 = v28 / 256 + v28 + (int32_t)((v30 & 1) != 0) & 255; // 0x4010ba
        int32_t v33 = g4; // 0x4010c5
        int32_t v34 = v32 + v33 & 0xffff | v33 & -0x10000; // 0x4010c5
        g4 = v34;
        int32_t v35 = v3; // 0x4010c8
        int32_t v36 = v25; // 0x4010d3
        if (v32 != (int32_t)*(char *)v35) {
            // if_4010c9_0_true
            v36 = v25 & -0x10000;
            // branch -> after_if_4010c9_0
        }
        // after_if_4010c9_0
        result = *v13;
        if (v36 == 0) {
            // 0x4010d7
            // branch -> 0x4010d9
            // 0x4010d9
            return 0;
        }
        // 0x4010d0
        v3 = (v31 / 512 ^ 2) - 1 + v35 - 2;
        int32_t v37 = v36 - 1; // 0x4010d3
        g5 = v37;
        if (v37 == 0) {
            // break -> 0x4010d9
            break;
        }
        v4 = (v30 & 0x200000) != 0;
        v5 = (v30 & 0x40000) != 0;
        v6 = (v30 & 0x4000) != 0;
        v7 = (v30 & 512) != 0;
        v8 = (v30 & 256) != 0;
        v9 = v31 != 0;
        v10 = v34;
        v1 = result;
        // continue -> 0x4010a2
    }
    // 0x4010d9
    return result;
}

// Address range: 0x4010df - 0x4011ff
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // edi
    int32_t v2;
    bool v3 = function_401000(v2); // 0x4010df
    g1 = (v3 ? 15 : 0) - (*(int32_t *)v1 & 15) > 15;
    *(char *)((g6 ? -4 : 4) + v1) = (char)v3;
    g2 = *(int32_t *)0;
    return function_401097(v2);
}

// --------------- Dynamically Linked Functions ---------------

// HANDLE WINAPI GetStdHandle(_In_ DWORD nStdHandle);
// BOOL WINAPI ReadFile(_In_ HANDLE hFile, _Out_ LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL WINAPI WriteFile(_In_ HANDLE hFile, _In_ LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: borland .net
// Detected functions: 4
// Decompiler release: v2.1.2 (2016-01-27)
// Decompilation date: 2016-02-22 11:21:10
